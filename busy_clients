#!/bin/bash

# Set paths
ROBOTS_FILE="/opt/bitnami/wordpress/robots.txt"
ACCESS_LOG="/opt/bitnami/apache2/logs/access_log"

# Optional: ipinfo token to raise rate limits, export IPINFO_TOKEN=xxxxxxxx
IPINFO_TOKEN="${IPINFO_TOKEN:-}"

# Simple cache to reduce external lookups
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/busy_clients"
CACHE_FILE="$CACHE_DIR/ipinfo.tsv"
mkdir -p "$CACHE_DIR"
touch "$CACHE_FILE"

# Usage helper
usage() {
  cat <<'EOF'
busy_clients [--list [DAYS]] [DAYS]

Without flags, prints a formatted table of IPs with totals, disallowed counts, city,country, and hostname.
--list prints a machine-friendly list with the same columns in a single line per IP.
If DAYS is omitted, defaults to 7.
EOF
}

# Mode and days parsing
MODE="table"
DAYS_BACK=""
case "$1" in
  --help|-h)
    usage
    exit 0
    ;;
  --list)
    MODE="list"
    if [[ -n "$2" ]]; then
      DAYS_BACK="$2"
    fi
    ;;
  *)
    if [[ -n "$1" ]]; then
      DAYS_BACK="$1"
    fi
    ;;
esac
DAYS_BACK="${DAYS_BACK:-7}"

# Check that required files exist
if [ ! -f "$ROBOTS_FILE" ]; then
  echo "Error: robots.txt not found at $ROBOTS_FILE"
  exit 1
fi

if [ ! -f "$ACCESS_LOG" ]; then
  echo "Error: Access log not found at $ACCESS_LOG"
  exit 1
fi

# Extract disallowed paths
DISALLOWED_PATHS=$(grep -i '^[[:space:]]*Disallow:' "$ROBOTS_FILE" \
  | awk '{print $2}' \
  | sed 's|/$||' \
  | sed '/^$/d' \
  | sort -u)

# Build a single regex for the last N days like 26/Aug/2025|25/Aug/2025|...
DATE_PATTERN=$(
  for i in $(seq 0 $((DAYS_BACK-1))); do
    date -d "$i days ago" "+%d/%b/%Y"
  done | paste -sd'|' -
)

# Temp files
TEMP_ALL=$(mktemp)
TEMP_VIOL=$(mktemp)
TOT_COUNTS=$(mktemp)
VIO_COUNTS=$(mktemp)
MERGED=$(mktemp)

# Ensure cleanup
cleanup() {
  rm -f "$TEMP_ALL" "$TEMP_VIOL" "$TOT_COUNTS" "$VIO_COUNTS" "$MERGED"
}
trap cleanup EXIT

# Collect all access log lines for the last N days
grep -E "$DATE_PATTERN" "$ACCESS_LOG" > "$TEMP_ALL"

# Collect only the lines that hit disallowed paths
: > "$TEMP_VIOL"
if [ -n "$DISALLOWED_PATHS" ]; then
  for path in $DISALLOWED_PATHS; do
    grep "\"GET ${path}" "$TEMP_ALL" >> "$TEMP_VIOL"
  done
fi

# Count total requests per IP
awk '{print $1}' "$TEMP_ALL" | sort | uniq -c > "$TOT_COUNTS"

# Count disallowed requests per IP
if [ -s "$TEMP_VIOL" ]; then
  awk '{print $1}' "$TEMP_VIOL" | sort | uniq -c > "$VIO_COUNTS"
else
  : > "$VIO_COUNTS"
fi

# Merge counts so that all clients appear, even if they have zero disallowed hits
awk '
  NR==FNR { tot[$2]=$1; next }
  { viol[$2]=$1; next }
  END {
    for (ip in tot) {
      v = (ip in viol) ? viol[ip] : 0
      printf "%s %d %d\n", ip, tot[ip], v
    }
  }
' "$TOT_COUNTS" "$VIO_COUNTS" > "$MERGED"

# Lookup helper: returns "City, CC" or "(unknown)"
lookup_geo() {
  local ip="$1"
  local cached
  cached=$(awk -v ip="$ip" -F'\t' '$1==ip {print $2}' "$CACHE_FILE" | head -n1)
  if [ -n "$cached" ]; then
    printf "%s" "$cached"
    return 0
  fi

  local url="https://ipinfo.io/${ip}"
  if [ -n "$IPINFO_TOKEN" ]; then
    url="${url}?token=${IPINFO_TOKEN}"
  fi

  local resp
  resp=$(curl -m 4 --retry 1 --retry-delay 1 -sS "$url") || resp=""

  local city country
  if command -v jq >/dev/null 2>&1; then
    city=$(printf '%s' "$resp" | jq -r '.city // empty')
    country=$(printf '%s' "$resp" | jq -r '.country // empty')
  else
    city=$(printf '%s' "$resp" | tr -d '\r' | grep -o '"city":[[:space:]]*"[^"]*"'    | head -1 | sed 's/.*"city":[[:space:]]*"\([^"]*\)".*/\1/')
    country=$(printf '%s' "$resp" | tr -d '\r' | grep -o '"country":[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"country":[[:space:]]*"\([^"]*\)".*/\1/')
  fi

  local out
  if [ -n "$city" ] && [ -n "$country" ]; then
    out="${city}, ${country}"
  elif [ -n "$country" ]; then
    out="${country}"
  elif [ -n "$city" ]; then
    out="${city}"
  else
    out="(unknown)"
  fi

  printf "%s\t%s\n" "$ip" "$out" >> "$CACHE_FILE"
  printf "%s" "$out"
}

# Hostname helper
lookup_host() {
  local ip="$1"
  local h
  h=$(host "$ip" 2>/dev/null | awk "/domain name pointer/ {print \$5}" | sed 's/\.$//')
  [ -z "$h" ] && h="(unresolved)"
  printf "%s" "$h"
}

# Output
if [ "$MODE" = "list" ]; then
  # Machine friendly list, one line per IP, includes city,country
  # Columns: ip total disallowed city,country hostname
  sort -k2,2nr -k1,1 "$MERGED" | while read -r ip total disallowed; do
    geo="$(lookup_geo "$ip")"
    hostn="$(lookup_host "$ip")"
    printf "%s\t%s\t%s\t%s\t%s\n" "$ip" "$total" "$disallowed" "$geo" "$hostn"
  done
  exit 0
fi

echo
echo "=== Clients in the past $DAYS_BACK days (total vs disallowed) ==="
printf "%-39s %7s %11s   %-24s %s\n" "IP" "total" "disallowed" "city,country" "hostname"
printf "%-39s %7s %11s   %-24s %s\n" "---------------------------------------" "------" "-----------" "------------" "--------"

sort -k2,2nr -k1,1 "$MERGED" | while read -r ip total disallowed; do
  hostname="$(lookup_host "$ip")"
  geo="$(lookup_geo "$ip")"
  printf "%-39s %7s %11s   %-24s %s\n" "$ip" "$total" "$disallowed" "$geo" "$hostname"
done

echo
echo "Total unique IPs: $(awk '{print $2}' "$TOT_COUNTS" | wc -l)"
if [ -s "$VIO_COUNTS" ]; then
  echo "Unique IPs with disallowed accesses: $(awk '{print $2}' "$VIO_COUNTS" | wc -l)"
else
  echo "Unique IPs with disallowed accesses: 0"
fi
